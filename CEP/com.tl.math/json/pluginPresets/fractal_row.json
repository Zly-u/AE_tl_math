{"composition": {"camera_position": "camera_pos","camera_rotation": "camera_rotation","camera_target": "camera_target","camera_zoom": "camera_zoom","compResolution": "compResolution","frame_rate": "fps","layerPosition": "layerPosition","layerScale": "layerScale","resolution": "resolution","time_frame": "timef","time_sec": "time"},"effectInfo": {"description": "based on http://glslsandbox.com/e#58173.7\\n\\ngenerates a simple fractal row. The base result is simple, but playing with it can have some strange/funny result.\\n\\nOptional: you can use the after effect camera","effectName": "tlMath","minimalPluginVersion": 115,"pluginVersion": 115,"presetName": "fractal_row","tags": ["fractal"," row"," iterations"," loop"," "]},"effectMode": {"evalModeB": false,"expr_modeB": true,"gl33_modeB": false},"flags": {"pixelsCallExternalInputB": [false,false,false,false],"presetHasWideInputB": false,"usesCameraB": true},"gl_expression": {"gl33_frag_error": "compiled successfully","gl33_frag_sh": "\\n//EXEMPE TO SHOW HOW THE PLUGIN WORKS\\n//A SHADER MUST START ITH A DEFINITION OF THE GLSL VERSION USED\\n// FOR NOW THE PLUGIN WORKS ONLY ITH 330 (for opengl 3.3)\\n// the same effect is written in expression rgb mode. \\n#version 330 \\n// let's call variables from After Effect\\n// THE PROCES IS uniform [TYPE] [variableName];\\n//uniform--> the function to call an external element in glsl\\n//type--> sampler2D for a texture from AE\\n// ------ float for a single dimention (time, slider or rotation param)\\n//-------- vec2  for a two dimension item (resolution)\\n//--------vec3 for a three dimension item (points/ color)\\n//--------bool  for checkbox\\n// Points are alayws defined as vec3 with this plugin. So if you have \\n// a shader with a 2D point, you can convert it latter.\\n// Slider are alays imported as float. if you want an integer you can convert\\n//on the fly: int(sliderName) \\n//variable Name: you define it in param setting.\\n//for the exemple we keep the default name\\nuniform sampler2D texture0; //get the layer source\\nuniform sampler2D texture1; // get an other layer\\nuniform float slider_1;// get  a slider from the UI\\nuniform vec3 point_1; // get  a pioint from the UI\\nuniform bool cbox_1; // get  a checkbox from the UI\\nuniform vec3 color_1; //get a color input\\nuniform vec2 resolution; //get  the resolution\\nin vec2 out_uvs; // get the uv (1,1) size of the layer\\n //invert texture for AE on y corrd. it's faster in glsl\\n  vec2 textUvs =vec2 (out_uvs.x, 1- out_uvs.y);\\nout vec4 fragColorOut; // the output varaible\\n// in glsl you can use gl_FragColorOut for the output but\\n// on some version of macos we have to define an out vec4 variable.\\n//if you develop on pc and want to share shaders, don't forget mac users...\\n// you can give it the name you want \\n\\n\\n// void main is the main part of the glsl program.\\n//here you make the main work of the effect.\\nvoid main(void)\\n{\\n    vec4 textureInput = texture(texture0,textUvs); // call the orginal  layer with the orginal position\\n    vec4 premix =mix (textureInput,vec4(color_1, 1.0), slider_1/100); //let's make a simple mix with color 1 influence by a slider\\n    //note we wrote vec4(color_1, 1.0). becaufe we have to mix a four color channel so we add a full alpha\\n    if (cbox_1){ // if the checkbox is activated\\n        // we import the layer1 ith an offset ith point1.\\n        \\n        // an offset has to be nromalized: (1,1) =(the layer x size normalized, the layer y scale normalized)\\n        // so an offset to stay in the picture has to be defined wetween 0 and 1\\n        // lets start with resolution/2 get the center. (for ex in fullhd wi get center (960/540)\\n        //if we substract the point coord we get the off value\\n        // 0 if the point is in the center. to get a normalized value to the layer we divide by the resoluton \\n        vec2 off;\\n        off.x =textUvs.x +( resolution.x/2 -point_1.x)/resolution.x;\\n        off.y =textUvs.y -( resolution.y/2 -point_1.y)/resolution.y;\\n        vec4 textureLayer = texture (texture1,off );\\n        fragColorOut = mix (textureInput,textureLayer, slider_1/100); //let's do some mix with a slider\\n    }else{\\n         fragColorOut =premix; // if checkbox not selected return premix\\n\\n    }\\n             //if you want to play with pixel coordonate activate the alpha ramp\\n         //alpha ramp \\n         //fragColorOut.a = gl_FragCoord.x/resolution.x;\\n}\\n\\n\\n\\n","gl33_vert_error": "compiled successfully","gl33_vert_sh": "#version 330 \\nin vec4 Position;\\nin vec2 UVs;\\nout vec4 out_pos;\\nout vec2 out_uvs;\\nuniform mat4 ModelviewProjection;\\nvoid main(void)\\n{\\nout_pos = ModelviewProjection * Position; \\n gl_Position = out_pos; \\nout_uvs = UVs;\\n}\\n"},"gui_settings": {"cboxGrp": {"grpName": "check box Group","grpVisibleB": true,"params": [{"defaultVal": [0],"name": "use_camera","visibleB": true},{"defaultVal": [0],"name": "cbox_2","visibleB": false},{"defaultVal": [0],"name": "cbox_3","visibleB": false},{"defaultVal": [0],"name": "cbox_4","visibleB": false},{"defaultVal": [0],"name": "cbox_5","visibleB": false},{"defaultVal": [0],"name": "cbox_6","visibleB": false},{"defaultVal": [0],"name": "cbox_7","visibleB": false},{"defaultVal": [0],"name": "cbox_8","visibleB": false},{"defaultVal": [0],"name": "cbox_9","visibleB": false},{"defaultVal": [0],"name": "cbox_10","visibleB": false}]},"colorGrp": {"grpName": "3d color Group","grpVisibleB": true,"params": [{"defaultVal": [1,1,1],"name": "color","visibleB": true},{"defaultVal": [1,1,1],"name": "color_2","visibleB": false},{"defaultVal": [1,1,1],"name": "color_3","visibleB": false},{"defaultVal": [1,1,1],"name": "color_4","visibleB": false},{"defaultVal": [1,1,1],"name": "color_5","visibleB": false},{"defaultVal": [1,1,1],"name": "color_6","visibleB": false},{"defaultVal": [1,1,1],"name": "color_7","visibleB": false},{"defaultVal": [1,1,1],"name": "color_8","visibleB": false},{"defaultVal": [1,1,1],"name": "color_9","visibleB": false},{"defaultVal": [1,1,1],"name": "color_10","visibleB": false}]},"layerGrp": {"current_layer": {"name": "texture0"},"extLayer_1": {"name": "texture1","visibleB": false},"extLayer_2": {"name": "texture2","visibleB": false},"extLayer_3": {"name": "texture3","visibleB": false},"extLayer_4": {"name": "texture4","visibleB": false},"grpName": "Layer Group","grpVisibleB": false},"pointGrp": {"grpName": "3d Point Group","grpVisibleB": false,"params": [{"defaultVal": [50,50,50],"name": "point_1","visibleB": false},{"defaultVal": [50,50,50],"name": "point_2","visibleB": false},{"defaultVal": [50,50,50],"name": "point_3","visibleB": false},{"defaultVal": [50,50,50],"name": "point_4","visibleB": false},{"defaultVal": [50,50,50],"name": "point_5","visibleB": false},{"defaultVal": [50,50,50],"name": "point_6","visibleB": false},{"defaultVal": [50,50,50],"name": "point_7","visibleB": false},{"defaultVal": [50,50,50],"name": "point_8","visibleB": false},{"defaultVal": [50,50,50],"name": "point_9","visibleB": false},{"defaultVal": [50,50,50],"name": "point_10","visibleB": false}]},"rotationGrp": {"grpName": "rotation Group","grpVisibleB": false,"params": [{"defaultVal": [0],"name": "rotation_1","visibleB": false},{"defaultVal": [0],"name": "rotation_2","visibleB": false},{"defaultVal": [0],"name": "rotation_3","visibleB": false},{"defaultVal": [0],"name": "rotation_4","visibleB": false},{"defaultVal": [0],"name": "rotation_5","visibleB": false},{"defaultVal": [0],"name": "rotation_6","visibleB": false},{"defaultVal": [0],"name": "rotation_7","visibleB": false},{"defaultVal": [0],"name": "rotation_8","visibleB": false},{"defaultVal": [0],"name": "rotation_9","visibleB": false},{"defaultVal": [0],"name": "rotation_10","visibleB": false}]},"sliderGrp": {"grpName": "Slider Group","grpVisibleB": true,"params": [{"defaultVal": [10],"name": "z_offset","visibleB": true},{"defaultVal": [5],"name": "z_depth","visibleB": true},{"defaultVal": [100],"name": "iterations","visibleB": true},{"defaultVal": [25],"name": "lengthx","visibleB": false},{"defaultVal": [10],"name": "bar_length_x","visibleB": true},{"defaultVal": [10],"name": "bar_length_y","visibleB": true},{"defaultVal": [10],"name": "bar_length_z","visibleB": true},{"defaultVal": [25],"name": "tube_length_x","visibleB": true},{"defaultVal": [25],"name": "tube_length_y","visibleB": true},{"defaultVal": [25],"name": "tube_length_z","visibleB": true}]}},"math_expression": {"alphaExpr": "return 1.;","alpha_error": "compiled successfully","blueExpr": "return inChannel;","blue_error": "compiled successfully","commonExpr": "vec2 onRep(vec2 p, float interval) {\\r\\n    return mod(p, interval) - interval * 0.5;\\r\\n}\\r\\n\\r\\nfloat barDist(vec2 p, float interval, float width) {\\r\\n    return length(max(abs(onRep(p, interval)) - width, 0.0));\\r\\n}\\r\\n\\r\\nfloat tubeDist(vec2 p, float interval, float width) {\\r\\n    return length(onRep(p, interval)) - width;\\r\\n}\\r\\n\\r\\nvec3 rotate(vec3 p, float angle, vec3 axis){\\r\\n    vec3 a = normalize(axis);\\r\\n    float s = sin(angle);\\r\\n    float c = cos(angle);\\r\\n    float r = 1.0 - c;\\r\\n    mat3 m = mat3(\\r\\n        a.x * a.x * r + c,\\r\\n        a.y * a.x * r + a.z * s,\\r\\n        a.z * a.x * r - a.y * s,\\r\\n        a.x * a.y * r - a.z * s,\\r\\n        a.y * a.y * r + c,\\r\\n        a.z * a.y * r + a.x * s,\\r\\n        a.x * a.z * r + a.y * s,\\r\\n        a.y * a.z * r - a.x * s,\\r\\n        a.z * a.z * r + c\\r\\n    );\\r\\n    return m * p;\\r\\n}\\r\\n\\r\\nfloat sceneDist(vec3 p) {\\r\\n    float bar_x = barDist(p.yz, 1., bar_length_x/100);\\r\\n    float bar_y = barDist(p.xz, 1., bar_length_y/100);\\r\\n    float bar_z = barDist(p.xy, 1., bar_length_z/100);\\r\\n\\r\\n    float tube_x = tubeDist(p.yz, 0.1,  tube_length_x/1000);\\r\\n    float tube_y = tubeDist(p.xz, 0.1,  tube_length_y/1000);\\r\\n    float tube_z = tubeDist(p.xy, 0.1,  tube_length_z/1000);\\r\\n\\r\\n    return max(max(max(min(min(bar_x, bar_y),bar_z), -tube_x), -tube_y), -tube_z);\\r\\n}","common_error": "compiled successfully","exprRGBModeB": true,"expr_current_channel": "inChannel","expr_pix": "pix","expr_rgb_channel": "inputRgb","greenExpr": "return inChannel;","green_error": "compiled successfully","redExpr": "return inChannel;","red_error": "compiled successfully","rgbExpr": "   //based on http://glslsandbox.com/e#58173.7\\r\\n   vec2 p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\\r\\n\\r\\n    vec3 cameraPos = vec3(0., 0., z_offset );\\r\\n    vec3 cameraTarget = vec3(1., 0.5, z_offset);\\r\\n    if (use_camera ==true){\\r\\n        cameraPos = camera_pos/vec3 (resolution, 1500);\\r\\n        cameraTarget =camera_target/vec3 (resolution, 1500);\\r\\n        \\r\\n    }\\r\\n\\r\\n    float screenZ = z_depth/10;\\r\\n    vec3 rayDirection = rotate(normalize(vec3(p, screenZ)), radians(z_offset * 10.), vec3(0.0, 0.0, 1.));\\r\\n\\r\\n    float depth = 0.0;\\r\\n    vec3 col = vec3(1.0);\\r\\n\\r\\n    for (int i = 0; i < int(iterations); i++) {\\r\\n        vec3 rayPos = cameraPos + rayDirection * depth;\\r\\n        float dist = sceneDist(rayPos);\\r\\n\\r\\n        if (dist < 0.0001) {\\r\\n            col = vec3(color) * (0.2 + float(i) / 100.0);\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        depth += dist;\\r\\n    }\\r\\n    return col; ","rgb_error": "compiled successfully"}}