{"composition": {"camera_position": "camera_pos","camera_rotation": "camera_rotation","camera_target": "camera_target","camera_zoom": "camera_zoom","compResolution": "compResolution","frame_rate": "fps","layerPosition": "layerPosition","layerScale": "layerScale","resolution": "resolution","time_frame": "timef","time_sec": "time"},"effectInfo": {"description": "based on https://www.shadertoy.com/view/wsSGRd  by  jaszunio15\\nNonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)\\n\\n\\n","effectName": "tlMath","minimalPluginVersion": 115,"pluginVersion": 115,"presetName": "universe","tags": ["shadertoy"]},"effectMode": {"evalModeB": false,"expr_modeB": false,"gl33_modeB": true},"flags": {"needsLumaB": false,"pixelsCallExternalInputB": [false,false,false,false],"presetHasWideInputB": true,"usesCameraB": false},"gl_expression": {"gl33_frag_error": "compiled successfully","gl33_frag_sh": "//shader from glslsandbox \\r// * Original shader from: https://www.shadertoy.com/view/wsSGRd r jaszunio15 l\\r#version 330\\r\\runiform float time_offset;\\runiform float rays;\\runiform float steps;\\runiform float sharpness;\\runiform float jitter;\\runiform float dither;\\runiform float brightness; \\runiform float depth;\\runiform float  fog_speed; \\runiform vec3 color1;\\runiform vec3 color2;\\runiform float  edge_length;\\rout vec4 fragColorOut;\\r\\runiform float time;\\runiform vec2 resolution;\\r\\r // shadertoy globals\\rfloat iTime = 0.0;\\rvec3  iResolution = vec3(0.0);\\r\\r\\r// Emulate a black texture\\r#define texture(s, uv) vec4(0.0)\\r\\r// --------[ Original ShaderToy begins here ]---------- //\\r//Generation settings\\r#define NOISE_ALPHA_MULTIPLIER 0.5\\r#define NOISE_SIZE_MULTIPLIER 1.8\\r\\r\\r//Rendering settings\\r\\rfloat RAYS_COUNT =  10* rays;\\rfloat STEP_MODIFIER = 1 + steps/1000;\\rfloat SHARPNESS  = sharpness /1000;\\r\\rfloat JITTERING =  jitter/100;\\rfloat DITHER  = dither/10;\\rfloat RENDER_DISTANCE =depth;\\r\\r#define   NOISE_LAYERS_COUNT 5.0\\r#define NEAR_PLANE 0.6\\r\\r//Camera and iTime\\r#define NEAR_PLANE 0.6\\r#define iTime_SCALE 1.0\\r#define CAMERA_SPEED 0.04\\r#define CAMERA_ROTATION_SPEED 0.06\\rfloat FOG_CHANGE_SPEED = fog_speed/100;\\r\\r\\r\\r// Emulate a black texture\\r#define texture(s, uv) vec4(0.0)\\r\\r// --------[ Original ShaderToy begins here ]---------- //\\r//Generation settings\\r#define NOISE_ALPHA_MULTIPLIER 0.5\\r#define NOISE_SIZE_MULTIPLIER 1.8\\r\\r\\r\\rfloat hash(vec3 v)\\r{\\r     return fract(sin(dot(v, vec3(11.51721, 67.12511, 9.7561))) * 1551.4172);   \\r}\\r\\rfloat getNoiseFromVec3(vec3 v)\\r{\\r    vec3 rootV = floor(v);\\r    vec3 f = smoothstep(0.0, 1.0, fract(v));\\r    \\r    //Cube vertices values\\r    float n000 = hash(rootV);\\r    float n001 = hash(rootV + vec3(0,0,1));\\r    float n010 = hash(rootV + vec3(0,1,0));\\r    float n011 = hash(rootV + vec3(0,1,1));\\r    float n100 = hash(rootV + vec3(1,0,0));\\r    float n101 = hash(rootV + vec3(1,0,1));\\r    float n110 = hash(rootV + vec3(1,1,0));\\r    float n111 = hash(rootV + vec3(1,1,1));\\r    \\r    //trilinear interpolation\\r    vec4 n = mix(vec4(n000, n010, n100, n110), vec4(n001, n011, n101, n111), f.z);\\r    n.xy = mix(vec2(n.x, n.z), vec2(n.y, n.w), f.y);\\r    return mix(n.x, n.y, f.x);\\r}\\r\\rfloat volumetricFog(vec3 v, float noiseMod)\\r{\\r    float noise = 0.0;\\r    float alpha = 1.0;\\r    vec3 point = v;\\r    for(float i = 0.0; i < NOISE_LAYERS_COUNT; i++)\\r    {\\r        noise += getNoiseFromVec3(point) * alpha;\\r         point *= NOISE_SIZE_MULTIPLIER;\\r        alpha *= NOISE_ALPHA_MULTIPLIER;\\r    }\\r    \\r    //noise = noise / ((1.0 - pow(NOISE_ALPHA_MULTIPLIER, NOISE_LAYERS_COUNT))/(1.0 - NOISE_ALPHA_MULTIPLIER));\\r    noise *= 0.575;\\r\\r    //edge + bloomy edge\\r\\r    float edge =  edge_length/10;\\r    noise = (0.5 - abs(edge * (1.0 + noiseMod * 0.05) - noise)) * 2.0;\\r    return (smoothstep(1.0 - SHARPNESS * 2.0, 1.0 - SHARPNESS, noise * noise) + (1.0 - smoothstep(1.3, 0.6, noise))) * 0.2;\\r}\\r\\r\\rvec3 nearPlanePoint(vec2 v, float time)\\r{\\r     return vec3(v.x, NEAR_PLANE * (1.0 + sin(time * 0.2) * 0.4), v.y);   \\r}\\r\\rvec3 fogMarch(vec3 rayStart, vec3 rayDirection, float time, float disMod)\\r{\\r    float stepLength = RENDER_DISTANCE / float(RAYS_COUNT);\\r     vec3 fog = vec3(0.0);   \\r    vec3 point = rayStart;\\r    \\r    for(int i = 0; i < RAYS_COUNT; i++)\\r    {\\r         point += rayDirection *stepLength;\\r        fog += volumetricFog(point, disMod) //intensity\\r            * mix(color1, color2 * (1.0 + disMod * 0.5), getNoiseFromVec3((point + vec3(12.51, 52.167, 1.146)) * 0.5)) //coloring\\r            * mix(1.0, getNoiseFromVec3(point * 40.0) * 2.0, DITHER)    //Dithering\\r            * getNoiseFromVec3(point * 0.2 + 20.0) * 2.0;    //Cutting big holes\\r        \\r        stepLength *= STEP_MODIFIER;\\r    }\\r    \\r    //There is a trick\\r    //Cutting mask in result, it will fake dynamic fog change, cover imperfections and add more 3D feeling\\r       fog = (fog / float(RAYS_COUNT)) * (pow(getNoiseFromVec3((rayStart + rayDirection * RENDER_DISTANCE)), 2.0) * 3.0 + disMod * 0.5);\\r    \\r    return fog;\\r}\\r\\r//Getting kick volume from spectrum\\rfloat getBeat()\\r{\\r     float sum = 0.0;\\r    for (float i = 0.0; i < 16.0; i++)\\r    {\\r         sum += texture(iChannel0, vec2(i * 0.001 + 0.0, 0.0)).r;   \\r    }\\r    return smoothstep(0.6, 0.9, pow(sum * 0.06, 2.0));\\r}\\r\\rvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\r{\\r    float time = iTime;\\r    float musicVolume = getBeat();\\r    vec2 res = iResolution.xy;\\r    vec2 uv = (2.0 * fragCoord - res) / res.x;\\r    \\r    //Random camera movement\\r    vec3 cameraCenter = vec3(sin(time * CAMERA_SPEED) * 10.0, time * CAMERA_SPEED * 10.0, cos(time * 0.78 * CAMERA_SPEED + 2.14) * 10.0);\\r    \\r    //Creating random rotation matrix for camera\\r    float angleY = sin(time * CAMERA_ROTATION_SPEED * 2.0);\\r    float angleX = cos(time * 0.712 * CAMERA_ROTATION_SPEED);\\r    float angleZ = sin(time * 1.779 * CAMERA_ROTATION_SPEED);\\r    mat3 rotation =   mat3(1, 0,             0,\\r                           0, sin(angleX),  cos(angleX),\\r                           0, -cos(angleX), sin(angleX))\\r                    * mat3(sin(angleZ),  cos(angleZ), 0,\\r                           -cos(angleZ), sin(angleZ), 0,\\r                           0,              0,           1)\\r                    * mat3(sin(angleY),  0, cos(angleY),\\r                           0,              1, 0,\\r                           -cos(angleY), 0, sin(angleY));\\r    \\r    vec3 rayDirection = rotation * normalize(nearPlanePoint(uv, time));\\r    vec3 rayStart = rayDirection * 0.2 + cameraCenter;    //Ray start with little clipping\\r    \\r    //Thanks to adx for jittering tip, looks and works really better with this line:\\r    rayStart += rayDirection * (hash(vec3(uv + 4.0, fract(iTime) + 2.0)) - 0.5) * JITTERING;\\r    \\r    vec3 fog = fogMarch(rayStart, rayDirection, time, musicVolume);\\r    \\r    //postprocess\\r    fog *= 2.5 *brightness;\\r    fog += 0.07 * mix(color1, color2, 0.5);    //Colouring the darkness\\r    fog = sqrt(smoothstep(0.0, 1.5, fog)); //Dealing with too bright areas (sometimes it happen)\\r    \\r    fragColor = vec4(fog * smoothstep(0.0, 10.0, iTime), 1.0);\\r}\\r// --------[ Original ShaderToy ends here ]---------- //\\r\\rvoid main(void)\\r{\\r    iTime = time +time_offset;\\r    iResolution = vec3(resolution, 0.0);\\r\\r    mainImage(fragColorOut, gl_FragCoord.xy);\\r}","gl33_vert_error": "compiled successfully","gl33_vert_sh": "#version 330 \\n in vec4 Position;\\nin vec2 UVs;\\nout vec4 out_pos;\\nout vec2 out_uvs;\\nuniform mat4 ModelviewProjection;\\nvoid main(void)\\n{\\nout_pos = ModelviewProjection * Position; \\n gl_Position = out_pos; \\nout_uvs = UVs;\\n}"},"gui_settings": {"cboxGrp": {"grpName": "check box Group","grpVisibleB": false,"params": [{"defaultVal": [0],"name": "cbox_1","visibleB": false},{"defaultVal": [0],"name": "cbox_2","visibleB": false},{"defaultVal": [0],"name": "cbox_3","visibleB": false},{"defaultVal": [0],"name": "cbox_4","visibleB": false},{"defaultVal": [0],"name": "cbox_5","visibleB": false},{"defaultVal": [0],"name": "cbox_6","visibleB": false},{"defaultVal": [0],"name": "cbox_7","visibleB": false},{"defaultVal": [0],"name": "cbox_8","visibleB": false},{"defaultVal": [0],"name": "cbox_9","visibleB": false},{"defaultVal": [0],"name": "cbox_10","visibleB": false}]},"colorGrp": {"grpName": "colors","grpVisibleB": true,"params": [{"defaultVal": [1,1,1],"name": "color1","visibleB": true},{"defaultVal": [1,1,1],"name": "color2","visibleB": true},{"defaultVal": [1,1,1],"name": "color_3","visibleB": false},{"defaultVal": [1,1,1],"name": "color_4","visibleB": false},{"defaultVal": [1,1,1],"name": "color_5","visibleB": false},{"defaultVal": [1,1,1],"name": "color_6","visibleB": false},{"defaultVal": [1,1,1],"name": "color_7","visibleB": false},{"defaultVal": [1,1,1],"name": "color_8","visibleB": false},{"defaultVal": [1,1,1],"name": "color_9","visibleB": false},{"defaultVal": [1,1,1],"name": "color_10","visibleB": false}]},"layerGrp": {"current_layer": {"name": "texture0"},"extLayer_1": {"name": "texture1","visibleB": false},"extLayer_2": {"name": "texture2","visibleB": false},"extLayer_3": {"name": "texture3","visibleB": false},"extLayer_4": {"name": "texture4","visibleB": false},"grpName": "Layer Group","grpVisibleB": false},"pointGrp": {"grpName": "3d Point Group","grpVisibleB": false,"params": [{"defaultVal": [50,50,50],"name": "point_1","visibleB": false},{"defaultVal": [50,50,50],"name": "point_2","visibleB": false},{"defaultVal": [50,50,50],"name": "point_3","visibleB": false},{"defaultVal": [50,50,50],"name": "point_4","visibleB": false},{"defaultVal": [50,50,50],"name": "point_5","visibleB": false},{"defaultVal": [50,50,50],"name": "point_6","visibleB": false},{"defaultVal": [50,50,50],"name": "point_7","visibleB": false},{"defaultVal": [50,50,50],"name": "point_8","visibleB": false},{"defaultVal": [50,50,50],"name": "point_9","visibleB": false},{"defaultVal": [50,50,50],"name": "point_10","visibleB": false}]},"rotationGrp": {"grpName": "rotation Group","grpVisibleB": false,"params": [{"defaultVal": [0],"name": "rotation_1","visibleB": false},{"defaultVal": [0],"name": "rotation_2","visibleB": false},{"defaultVal": [0],"name": "rotation_3","visibleB": false},{"defaultVal": [0],"name": "rotation_4","visibleB": false},{"defaultVal": [0],"name": "rotation_5","visibleB": false},{"defaultVal": [0],"name": "rotation_6","visibleB": false},{"defaultVal": [0],"name": "rotation_7","visibleB": false},{"defaultVal": [0],"name": "rotation_8","visibleB": false},{"defaultVal": [0],"name": "rotation_9","visibleB": false},{"defaultVal": [0],"name": "rotation_10","visibleB": false}]},"sliderGrp": {"grpName": "Slider Group","grpVisibleB": true,"params": [{"defaultVal": [3],"name": "time_offset","visibleB": true},{"defaultVal": [15],"name": "rays","visibleB": true},{"defaultVal": [7],"name": "steps","visibleB": true},{"defaultVal": [9],"name": " sharpness","visibleB": true},{"defaultVal": [3],"name": "jitter","visibleB": true},{"defaultVal": [3],"name": "dither","visibleB": true},{"defaultVal": [2],"name": "depth","visibleB": true},{"defaultVal": [5],"name": "brightness","visibleB": true},{"defaultVal": [2],"name": "fog_speed","visibleB": true},{"defaultVal": [5],"name": "edge_length","visibleB": true}]}},"math_expression": {"alphaExpr": "return inChannel;","alpha_error": "compiled successfully","blueExpr": "return inChannel;","blue_error": "compiled successfully","commonExpr": "float getLuma(vec4 text)\\n {\\n return 0.3 * text.r + 0.59 * text.g + 0.11 * text.b; \\n}\\nvec4 textureOffset(sampler2D tex2d, vec2 off) {\\nvec2 uv_AE = out_uvs;\\nuv_AE.x =textUvs.x + off.x; \\nuv_AE.y = textUvs.y + off.y; \\nvec4 textureIn = texture(tex2d, uv_AE); \\n return  textureIn; \\n}","common_error": "compiled successfully","exprRGBModeB": true,"expr_current_channel": "inChannel","expr_pix": "pix","expr_rgb_channel": "inputRgb","greenExpr": "return inChannel;","green_error": "compiled successfully","redExpr": "return inChannel;","red_error": "compiled successfully","rgbExpr": "return inputRgb;","rgb_error": "compiled successfully"}}